#!/bin/bash

MODE=

export WG_OUTPUT=${WG_OUTPUT:-wg-quick}
export WG_DEFAULT_GW=${WG_DEFAULT_GW:-no}

APP_NAME="$0"
SHOW_HELP=

for arg; do
  case $arg in
    --qr)
      shift
      MODE=qr
      ;;

    --shell)
      shift
      MODE=shell
      ;;

    --write)
      shift
      MODE=write
      ;;

    --up)
      shift
      MODE=up
      ;;

    --down)
      shift
      MODE=down
      ;;

    --wg-quick)
      shift
      export WG_OUTPUT=wg-quick
      ;;

    --openwrt)
      shift
      export WG_OUTPUT=openwrt
      ;;

    --mikrotik)
      shift
      export WG_OUTPUT=mikrotik
      ;;

    --default)
      shift
      export WG_DEFAULT_GW=yes
      ;;

    --ssh)
      SSH_SERVER="$2"
      shift 2
      MODE=ssh
      ;;

    -h|--help)
      shift
      SHOW_HELP=1
      ;;

    --*)
      echo "unknown $arg."
      exit 1
      ;;
    
    *)
      break
      ;;
  esac
done

usage() {
  stderr "$APP_NAME" "[options]" "$@"
  stderr ""
  stderr "Options:"
  stderr " --qr: output QR code"
  stderr " --shell: output shell commands"
  stderr " --write: write configuration file (to configs/wg-*.conf)"
  stderr " --up: wg-quick up"
  stderr " --down: wg-quick down"
  stderr " --ssh USER@HOST: upload ssh config to remote machine"
  stderr " --wg-quick: output wg-quick compatible configuration"
  stderr " --openwrt: output openwrt compatible configuration"
  stderr ""
  exit 1
}

run_server_and_client() {
  if [[ -n "$SHOW_HELP" ]] || [[ $# -ne 2 ]]; then
    usage "<server-config>" "<client-config>"
    exit 1
  fi

  server_name="$1"
  server_config="servers/$server_name.conf"

  client_name="$2"
  client_config="clients/$client_name.conf"

  if [[ ! -e "$server_config" ]]; then
    stderr "The $server_config does not exist!"
    exit 1
  fi

  if [[ ! -e "$client_config" ]]; then
    stderr "The $client_config does not exist!"
    exit 1
  fi

  if [[ -n "$MODE" ]]; then
    ${MODE}_emit "$0" "$@"
    exit 0
  fi
}

run_server() {
  if [[ -n "$SHOW_HELP" ]] || [[ $# -ne 1 ]]; then
    usage "<server-config>"
    exit 1
  fi

  server_name="$1"
  server_config="servers/$server_name.conf"

  if [[ ! -e "$server_config" ]]; then
    stderr "The $server_config does not exist!"
    exit 1
  fi

  if [[ -n "$MODE" ]]; then
    ${MODE}_emit "$0" "$@"
    exit 0
  fi
}

qr_emit() {
  $@ | qrencode -t ansiutf8
}

shell_emit() {
  export interface_name="wg-${server_name}"
  if [[ "$WG_OUTPUT" == "openwrt" ]]; then
    export interface_name="wireguard"
  fi

  echo_wgconf "mkdir -p /etc/wireguard/"
  echo_wgconf "umask 0177"
  echo_wgconf "cat <<EOF > /etc/wireguard/${interface_name}.conf"
  $@
  echo_wgconf "EOF"
  echo_wgconf ""

  if [[ "$WG_OUTPUT" == "wg-quick" ]]; then
    echo ""
    echo "systemctl enable wg-quick@wg-${server_name}.service"
    echo "systemctl restart wg-quick@wg-${server_name}.service"
    echo ""
  fi

  if [[ "$WG_OUTPUT" == "openwrt" ]]; then
    cat <<"EOF"
cat <<"WGEOF" > /etc/hotplug.d/iface/99-wireguard
#!/bin/sh

if [ "$ACTION" == "ifup" ] && [ -f "/etc/wireguard/$INTERFACE.conf" ]; then
  /usr/bin/wg addconf "$INTERFACE" /etc/wireguard/$INTERFACE.conf
fi
WGEOF
EOF
    echo "chmod +x /etc/hotplug.d/iface/99-wireguard"
    echo "ifup ${interface_name}"
  fi
}

config_file() {
  if [[ -n "$client_name" ]]; then
    mkdir -p "$(pwd)/configs/${client_name}"
    if [[ "$WG_DEFAULT_GW" == "yes" ]]; then
      echo "$(pwd)/configs/${client_name}/${server_name}def.conf"
    else
      echo "$(pwd)/configs/${client_name}/${server_name}.conf"
    fi
  else
    mkdir -p "$(pwd)/configs"
    echo "$(pwd)/configs/${server_name}.conf"
  fi
}

write_emit() {
  file="$(config_file)"
  umask 0077
  echo "write $file"
  $@ > "$file"
}

wg_quick_emit() {
  file="$(config_file)"
  ACTION="$1"
  shift

  write_emit "$@"
  echo "wg-quick $ACTION $file"
  wg-quick "$ACTION" "$file"
}

up_emit() {
  wg_quick_emit "up" "$@"
}

down_emit() {
  wg_quick_emit "down" "$@"
}

ssh_emit() {
  echo "ssh $SSH_SERVER"
  ( echo_wgconf 'set -x'; shell_emit "$@" ) | ssh -T "$SSH_SERVER"
}

echo_wgconf() {
  if [[ "$WG_OUTPUT" == "wg-quick" || "$WG_OUTPUT" == "openwrt" ]]; then
    echo "$@"
  fi
}

echo_wgquick() {
  if [[ "$WG_OUTPUT" == "wg-quick" ]]; then
    echo "$@"
  fi
}

echo_openwrt() {
  if [[ "$WG_OUTPUT" == "openwrt" ]]; then
    echo "$@"
  fi
}

echo_mikrotik() {
  if [[ "$WG_OUTPUT" == "mikrotik" ]]; then
    echo "$@"
  fi
}

if_ne() {
  key="$1"
  shift
  [[ -z "$key" ]] || [[ "$key" == "no" ]] || "$@"
}

emit_config_interface() {
  local interface_config="$1"
  local interface_config_name=$(basename "$interface_config" .conf)
  local interface_publickey=$(require_value "$interface_config" "PublicKey")
  local interface_privatekey=$(require_value "$interface_config" "PrivateKey")
  local interface_address=$(get_value "$interface_config" "Address")
  local interface_listenport=$(get_value "$interface_config" "ListenPort")
  local interface_default_gateway=$(get_value "$interface_config" "DefaultGateway")
  local interface_fwmark=$(get_value "$interface_config" "FwMark")
  local interface_mtu=$(get_value "$interface_config" "MTU")

  local peer_config="$2"
  local peer_dns=$(get_value "$peer_config" "DNS")
  local peer_mtu=$(get_value "$peer_config" "MTU")

  if [[ -z "$interface_name" ]]; then
    interface_name="$interface_config_name"
  fi

  if [[ -z "$interface_address" ]]; then
    interface_address="$(alloc_address "$interface_config_name" "$interface_publickey" "$start_ip" "$end_ip")/32"
  fi

  echo_wgconf "[Interface]"
  echo_mikrotik ":if ([/interface/wireguard/find name=\"$interface_name\"]) do={} else={ /interface/wireguard/add name=\"$interface_name\" }"
  echo_mikrotik "/interface/wireguard/peers/remove [find interface=\"$interface_name\"]"

  echo_wgconf "PrivateKey=$interface_privatekey"
  echo_mikrotik "/interface/wireguard/set [find name=\"$interface_name\"] private-key=\"$interface_privatekey\""

  if_ne "$interface_fwmark" echo_wgconf "FwMark=$interface_fwmark"

  if_ne "$interface_address" echo_wgquick "Address=$interface_address"
  if_ne "$interface_address" echo_mikrotik ":if ([/ip/address/find address=\"$interface_address\" interface=\"$interface_name\"]) do={} else={ /ip/address/add address=\"$interface_address\" interface=\"$interface_name\" }"

  echo_wgquick "ListenPort=${interface_listenport:-$DEFAULT_LISTEN_PORT}"
  echo_mikrotik "/interface/wireguard/set [find name=\"$interface_name\"] listen-port=\"${interface_listenport:-$DEFAULT_LISTEN_PORT}\""

  if_ne "$interface_default_gateway" echo_wgquick "PostUp=sysctl net.ipv4.ip_forward=1; iptables -A FORWARD -i %i -j ACCEPT; iptables -t nat -A POSTROUTING -o $interface_default_gateway -j MASQUERADE"
  if_ne "$interface_default_gateway" echo_wgquick "PostDown=iptables -D FORWARD -i %i -j ACCEPT; iptables -t nat -D POSTROUTING -o $interface_default_gateway -j MASQUERADE"

  if_ne "$peer_dns" echo_wgquick "DNS=$peer_dns"

  if_ne "$peer_mtu" echo_wgquick "MTU=$peer_mtu"
  if_ne "$peer_mtu" echo_mikrotik "/interface/wireguard/set [find name=\"$interface_name\"] mtu=\"$peer_mtu\""

  echo
}

emit_config_peer() {
  local interface_config="$2"
  local interface_config_name=$(basename "$interface_config" .conf)

  if [[ -z "$interface_name" ]]; then
    interface_name="$interface_config_name"
  fi

  local peer_config="$1"

  local peer_name=$(basename "$peer_config" .conf)
  local peer_publickey=$(require_value "$peer_config" "PublicKey")
  local peer_address=$(get_value "$peer_config" "Address")
  local peer_routes=$(get_value "$peer_config" "Routes_${interface_config_name}" "Routes")
  local interface_keepalive=$(get_value "$interface_config" "PersistentKeepalive")
  local peer_endpoint=$(get_value "$peer_config" "Endpoint")
  local peer_listenport=$(get_value "$peer_config" "ListenPort")

  local peer_disallowed=$(get_value "$peer_config" "Interface_${interface_config_name}")

  if [[ "$peer_disallowed" == 0 ]]; then
    return 0
  fi

  local psk=$(get_psk "$peer_config" "$interface_config")

  if [[ -z "$peer_address" ]]; then
    peer_address=$(alloc_address "$peer_name" "$peer_publickey" "$start_ip" "$end_ip")
  fi

  echo_wgconf "[Peer]"
  echo_wgconf "PublicKey=$peer_publickey"
  echo_mikrotik "/interface/wireguard/peers/add interface=\"$interface_name\" comment=\"$peer_name\" public-key=\"$peer_publickey\" allowed-address=\"$peer_address\""

  if_ne "$psk" echo_wgconf "PresharedKey=$psk"
  if_ne "$psk" echo_mikrotik "/interface/wireguard/peers/set [find interface=\"$interface_name\" public-key=\"$peer_publickey\"] preshared-key=\"$psk\""

  if_ne "$peer_endpoint" echo_wgconf "Endpoint=$peer_endpoint:${peer_listenport:-$DEFAULT_LISTEN_PORT}"
  if_ne "$peer_endpoint" echo_mikrotik "/interface/wireguard/peers/set [find interface=\"$interface_name\" public-key=\"$peer_publickey\"] endpoint=\"$peer_endpoint:${peer_listenport:-$DEFAULT_LISTEN_PORT}\""

  if_ne "$interface_keepalive" echo_wgconf "PersistentKeepalive=$interface_keepalive"
  if_ne "$interface_keepalive" echo_mikrotik "/interface/wireguard/peers/set [find interface=\"$interface_name\" public-key=\"$peer_publickey\"] persistent-keepalive=\"$interface_keepalive\""

  if_ne "$peer_address" echo_wgconf "AllowedIPs=$peer_address"

  for route in $peer_routes; do
    echo_wgconf "AllowedIPs=$route"
    echo_mikrotik "/interface/wireguard/peers/set [find interface=\"$interface_name\" public-key=\"$peer_publickey\"] allowed-address=([get [find interface=\"$interface_name\" public-key=\"$peer_publickey\"] allowed-address], \"$route\")"
    if_ne "$interface_address" echo_mikrotik ":if ([/ip/address/find address=\"$interface_address\" interface=\"$interface_name\"]) do={} else={ /ip/address/add address=\"$interface_address\" interface=\"$interface_name\" }"
  done

  if_ne "$WG_DEFAULT_GW" echo_wgconf "AllowedIPs=0.0.0.0/0"
  if_ne "$WG_DEFAULT_GW" echo_mikrotik "/interface/wireguard/peers/set [find interface=\"$interface_name\" public-key=\"$peer_publickey\"] allowed-address=([get [find interface=\"$interface_name\" public-key=\"$peer_publickey\"] allowed-address], \"0.0.0.0/0\")"

  echo
}
